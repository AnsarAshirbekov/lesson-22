# а) Напишите функцию, которая будет создавать файл, с задержкой 1
# секунду.
# б) Запустите циклом 100 таких функций, а также замерьте время.
# в) Добавьте функционал многопоточного запуска, с замером времени

# Поток - наименьшая единица обработки, которой может управлять операционная система.
# В рамках одного процесса может быть несколько потоков, которые выполняются одновременно,
# разделяя между собой ресурсы процесса.
import threading # модуль предоставляет классы и функции для создания и управления потоками, что позволяет выполнять 
                 # несколько операций одновременно
import time      # предоставляет функционал для работы со временем

# Напишем функцию для создания какого-либо файла, с задержкой перед созданием в 1 секунду 
def create_file(i):
    time.sleep(1)
    with open(f'file{i}.txt', 'w') as file:
        file.write('Hello world!')

# зафиксируем время перед началом работы
start = time.time()
print(start)

if __name__ == '__main__':
    # создадим список для хранения каждого потока, он нам нужен для того, чтобы по нему можно было пройтись циклом
    threads = []
    # запускаем цикл в 100 итераций
    for i in range(100):
        # Чтобы нам создать поток, нужно его инициализировать как класс Thread из модуля threading, передав ему целевую
        # функцию и ее аргументы
        thread = threading.Thread(target = create_file, args = (i,))
        # запускаем каждый поток, они будут работать одновременно, параллельно, независимо друг от друга
        thread.start()
        # добавляем каждый поток в список потоков
        threads.append(thread)

    # До тех пор, пока мы не создали переменную thread и не запустили ее, у нас был только один поток - основной, который 
    # выполнял все строчки кода. Он, дойдя до строчки с созданием потоков, затем их запускает start(), передает каждый
    # поток в список, и, не дожидаясь выполнения всех этих потоков, переходит к следующим строкам кода. Но нам нужно, чтобы
    # каждый поток выполнил свою работу и завершился. Для этого нужно сказать основному потоку, чтобы он подождал, пока
    # пока все остальные потоки не выполнят свою работу. Для этого нужно как бы "присоединить" каждый поток из списка 
    # к другому, это остановит основной поток от дальнейшего выполнения кода, пока все остальные потоку не выполнятся.

    for thread in threads:
        thread.join()

# Фиксируем время после завершения работы
end = time.time()
# Выводим время, затраченное на выполнение работы
print(f'Execution time = {end - start}')